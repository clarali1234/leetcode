
# 1. number of island 
    dfs recursion + visited set, time O(mn), space O(mn)
    dfs recursion + change grid cell, time O(mn), space O(depth of recursion)
    iterative dfs to aviod stack overflow
    # bfs vs dfs
    both bfs and dfs are used to search for graph
    bfs is queue based implementation, when we visited a node, we visited all of its 
    neighrbo first which means that we go wide then go deep
    dfs is stack based implementatio, when we visited a node, we visited its neighbor
    and call dfs for this neighbor then go wide

    bfs is used to find shortest path for simple graph
    dfs is used to explore all the possibility
    
# iterative dfs
class Solution(object):
    def numberIslands(self, grid):
        self.res = 0
        self.visited = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1' and (i, j) not in self.visited:
                    self.stack = [[i, j]]
                    self.visited.add((i, j))
                    self.dfs(grid)
                    self.res += 1
        return self.res
                    
    
    def dfs(self, grid):
        
        while self.stack:
            x, y = self.stack.pop()
            for dx, dy in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                new_x = x + dx
                new_y = y + dy
                if 0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]) and grid[new_x][new_y] == '1' and (new_x, new_y) not in self.visited:
                    self.visited.add((new_x, new_y))
                    self.stack.append((new_x, new_y))
        
test = Solution()
grid = [['1', '0', '1'],
        ['1', '1', '1'],
        ['1', '0', '1']]
print(test.numberIslands(grid)) # return 2


# bfs
import collections
class Solution(object):
    def numberIslands(self, grid):
        self.res = 0
        self.visited = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1' and (i, j) not in self.visited:
                    self.q = collections.deque([(i, j)])
                    self.visited.add((i, j))
                    self.bfs(grid)
                    self.res += 1
        return self.res
                    
    
    def bfs(self, grid):
        
        while self.q:
            x, y = self.q.popleft()
            for dx, dy in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                new_x = x + dx
                new_y = y + dy
                if 0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]) and grid[new_x][new_y] == '1' and (new_x, new_y) not in self.visited:
                    self.visited.add((new_x, new_y))
                    self.q.append((new_x, new_y))
        
test = Solution()
grid = [['1', '0', '1'],
        ['1', '1', '1'],
        ['1', '0', '1']]
print(test.numberIslands(grid)) # return 2



# follow up1: area of each island 

class Solution(object):
    def areaIsland(self, grid):
        self.res = []
        self.visited = set()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1' and (i, j) not in self.visited:
                    self.area = 0
                    self.visited.add((i, j))
                    self.dfs(grid, i, j)
                    self.res.append(self.area)
        return self.res
    
    def dfs(self,grid, x, y):
        
        self.area += 1
        for dx, dy in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
            new_x = x + dx
            new_y = y + dy
            if 0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]) and (new_x, new_y) not in self.visited and grid[new_x][new_y] == '1':
                self.visited.add((new_x, new_y))
                self.dfs(grid, new_x, new_y)
        
test = Solution()
grid = [['1', '0', '1'],
        ['1', '0', '1']]
        
print(test.areaIsland(grid)) # return 2




# 2. food delivery
# valid pickup order 
'''
就是地里常有的题，给你一个pickup 和delivery的order序列，问这个序列是否为有效序列。
例如 P1D1P3P2D2D3  ，主要判断标准其实就是对于某个orderId，pickup一定要在delivery发生之前.除此以外，还有些conner case，
例如同一个order,pickup 了两次或者deliver了两次，都是invalid的。P1 D1 P1 D1也是invalid的，不能有重复的pick up

'''

import collections
class Solution(object):
    def validOrder(self, orders):
        p_set = set() # set of all pickup
        set_ = set() # set of pickup and delivery pair
        for ele in orders:
            if ele.startswith('P'): # pickup
                if ele in p_set:
                    return False
                p_set.add(ele)
                set_.add(ele)
            else: # delivery
                if 'P' + ele[1] not in set_:
                    return False
                set_.remove('P' + ele[1])

        return len(set_) == 0
        
test = Solution()
orders = ['P1', 'D1', 'D2', 'P2']
print(test.validOrder(orders)) # return 2

# return all possibility
class Solution(object):
    def foodDelivery(self, n):
        if n == 0:
            return []
        if n == 1:
            return [['P1', 'D1']]
                     
        self.n = n
        self.res = []
        self.dfs(1, 1, ['P1', 'D1'])
        return self.res
        
    
    def dfs(self, P, D, cur):
        if P == self.n and D == self.n:
            self.res.append(cur)
            return 
        # [p1, d1]
        for i in range(len(cur)): # insert p at (0, len(cur) -1)
            cur1 = cur[:i] + ['P' + str(P + 1)] + cur[i:]
            for j in range(i + 1, len(cur1)):
                cur_path = cur1[:j] + ['D' + str(D + 1)] + cur1[j:]
                self.dfs(P + 1, D + 1, cur_path)
            cur1.append('D' + str(D + 1))
            self.dfs(P + 1, D + 1, cur1)
                           
        self.dfs(P + 1, D + 1, cur + ['P' + str(P + 1), 'D' + str(D + 1)])
                 
test = Solution()
print(test.foodDelivery(2)) # return 2
         
         
 # count all pickup and delivery options
 class Solution:
    def countOrders(self, n: int) -> int:
        res = 1
        mod = 10 ** 9 + 7
        for i in range(2, n + 1):
            res *= (2 * i - 1) * i
        return res % mod
