BFS

# time O(m*m*n) # m is length of words, n is word numbers, m * n possible words, and takes m to get each new word
# space O(m * n)

word_set = set(wordList)
        visited = set()
        visited.add(beginWord)
        q = deque([beginWord])
        step = 1
        while q:
            for _ in range(len(q)):
                word = q.popleft()
                if word == endWord:
                    return step
                for index in range(len(word)):
                    char = word[index]
                    for j in range(ord('a'), ord('z') + 1):
                        new_c = chr(j)
                        new_w = word[:index] + new_c + word[index + 1: ]
                        if new_w in word_set and new_w not in visited:
                            visited.add(new_w)
                            q.append(new_w)
            step += 1
        return 0
        
        

time : where M is the length of words and N is the total number of words in the input word list. 
Finding out all the transformations takes M iterations for each of the N words. 
Also, breadth first search in the worst case might go to each of the N words.

space : to store all M transformations for each of the N words, 
in the all_combo_dict dictionary. Visited dictionary is of N size. 
Queue for BFS in worst case would need space for all N words.


class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        wordset = set(wordList)
        queue = collections.deque([(beginWord, 1)])
        while queue:
            word, length = queue.popleft()
            if word == endWord:
                return length
            for i in range(len(word)):
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    new_word = word[:i] + c + word[i + 1:]
                    if new_word in wordset and new_word != word:
                        queue.append((new_word, length + 1))
                        wordset.remove(new_word)
        return 0
