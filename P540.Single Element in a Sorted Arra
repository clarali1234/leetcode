# brute force 遍历每一个数字，如果既不等于左边也不等于右边，则返回， 注意corner cases
time O(n)
class Solution(object):
    def singleNonDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 
        
        if len(nums) == 1:
            return nums[0]
        
        if nums[0] != nums[1]:
            return nums[0]
        
        for i in range(1, len(nums) - 1):
            if nums[i] != nums[i - 1] and nums[i] != nums[i + 1]:
                return nums[i]
        return nums[-1]
        
        
# 遍历数组，index increase by 2
# time O(n/2)
class Solution(object):
    def singleNonDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 1:
            return nums[0]
        
        for i in range(0, len(nums) - 1, 2):
            if nums[i] != nums[i + 1]:
                return nums[i]
        return nums[-1]
 
 # binary search 
二分判断逻辑（重点）

在 mid 位置：
如果 mid 是 奇数，让它变成偶数（mid -= 1）
比较 nums[mid] 和 nums[mid + 1]

情况分析：
情况	说明	搜索方向
nums[mid] == nums[mid+1]	single 在右边	left = mid + 2
nums[mid] != nums[mid+1]	single 在左边（或 mid）	right = mid
 
 class Solution(object):
    def singleNonDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        left, right = 0, len(nums) - 1 #[left, right]
        while (left < right):
            mid = left + (right - left) / 2
            if mid % 2 == 1: 
            # ensure mid is even
              mid -= 1
              # value is on the left 
            if nums[mid] != nums[mid + 1]:
                right = mid
              # value is on the right
            else:
                left = mid + 2
        return nums[left]

