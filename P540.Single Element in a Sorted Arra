# brute force 遍历每一个数字，如果既不等于左边也不等于右边，则返回， 注意corner cases
time O(n)
class Solution(object):
    def singleNonDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 
        
        if len(nums) == 1:
            return nums[0]
        
        if nums[0] != nums[1]:
            return nums[0]
        
        for i in range(1, len(nums) - 1):
            if nums[i] != nums[i - 1] and nums[i] != nums[i + 1]:
                return nums[i]
        return nums[-1]
        
        
# 遍历数组，index increase by 2
# time O(n/2)
class Solution(object):
    def singleNonDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 1:
            return nums[0]
        
        for i in range(0, len(nums) - 1, 2):
            if nums[i] != nums[i + 1]:
                return nums[i]
        return nums[-1]
 
 # binary search 
二分判断逻辑（重点）

在 mid 位置：
如果 mid 是 奇数，让它变成偶数（mid -= 1）
比较 nums[mid] 和 nums[mid + 1]

情况分析：
情况	说明	搜索方向
nums[mid] == nums[mid+1]	single 在右边	left = mid + 2
nums[mid] != nums[mid+1]	single 在左边（或 mid）	right = mid
 
 class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l = 0
        r = len(nums) - 1

        while l < r:
            m = (l + r) // 2
            if m % 2:
                m = m - 1

            if nums[m] == nums[m + 1]:
                l = m + 2
            else:
                r = m 

        return nums[l]

