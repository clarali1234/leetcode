# 最长路径有两种情况：
# 1.最长条路径经过根节点，那么只需要找出根节点的左右两棵子树的最大深度然后相加即可。
# 2.最长路径没有经过根节点，那么只需要找出根节点的左子树或者根节点的右子树作为根的最长路径度即可。递归调用，
# 自底向上查找子树的深度，如果某一个左子树与右子树深度之和大于当前纪录的直径，那么替换为当前直径，递归完成之后即可找出直径。

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0

        # case1: pass through the root
        case_1 = 0
        if root.left:
            case_1 += self.get_height(root.left) + 1
        if root.right:
            case_1 += self.get_height(root.right) + 1

        # case2: didn't pass through the root
        case_2 = max(self.diameterOfBinaryTree(root.left), self.diameterOfBinaryTree(root.right))
        return max(case_1, case_2)

    def get_height(self, node):
        if not node: 
            return 0
        if not node.left and not node.right:
            return 0

        l_height = self.get_height(node.left)
        r_height = self.get_height(node.right)

        return max(l_height, r_height) + 1
        
